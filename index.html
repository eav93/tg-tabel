<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Отчет смены → Telegram Share</title>
  <meta name="description" content="Форма для генерации текста отчета и отправки через Telegram Share." />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600&family=Unbounded:wght@500;700&display=swap"
    rel="stylesheet"
  />
  <style>
    :root {
      --bg: #f6f2ea;
      --ink: #1f252c;
      --muted: #5a646f;
      --card: #fffaf2;
      --accent: #0d7a71;
      --accent-2: #f06a4f;
      --accent-3: #f0c94f;
      --line: #e7dfd2;
      --shadow: 0 18px 40px rgba(20, 24, 28, 0.12);
      --radius: 18px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
      color: var(--ink);
      background: radial-gradient(1100px 600px at 10% -10%, #ffe7c2, transparent),
        radial-gradient(900px 500px at 95% 10%, #b9efe8, transparent),
        linear-gradient(180deg, #f6f2ea, #f3efe6);
      min-height: 100vh;
    }

    .page {
      position: relative;
      overflow: hidden;
      padding: 32px 18px 60px;
    }

    .page::before,
    .page::after {
      content: "";
      position: absolute;
      width: 360px;
      height: 360px;
      border-radius: 50%;
      filter: blur(0px);
      opacity: 0.25;
      z-index: 0;
    }

    .page::before {
      background: #f06a4f;
      top: -120px;
      right: -120px;
    }

    .page::after {
      background: #0d7a71;
      bottom: -160px;
      left: -140px;
    }

    .container {
      position: relative;
      z-index: 1;
      max-width: 980px;
      margin: 0 auto;
      display: grid;
      gap: 18px;
    }

    header {
      display: grid;
      gap: 10px;
    }

    h1 {
      font-family: "Unbounded", "IBM Plex Sans", sans-serif;
      font-size: clamp(28px, 4vw, 44px);
      line-height: 1.05;
      margin: 0;
    }

    .subtitle {
      font-size: 16px;
      color: var(--muted);
      max-width: 640px;
    }

    .panel {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: var(--shadow);
      display: grid;
      gap: 16px;
    }

    .panel-title {
      font-family: "Unbounded", "IBM Plex Sans", sans-serif;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .panel-title span {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--accent-2);
      display: inline-block;
    }

    .grid {
      display: grid;
      gap: 14px;
    }

    .grid.two {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .grid.three {
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }

    label {
      display: grid;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }

    input,
    select,
    textarea {
      font-family: "IBM Plex Sans", sans-serif;
      font-size: 15px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: #fff;
      color: var(--ink);
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(13, 122, 113, 0.15);
    }

    .inline {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: #fff3dd;
      color: #7a4b2a;
      font-size: 12px;
    }

    .switch {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }

    .switch input {
      width: 18px;
      height: 18px;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 12px 18px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
    }

    button:active {
      transform: translateY(1px);
    }

    .primary {
      background: var(--accent);
      color: white;
      box-shadow: 0 12px 24px rgba(13, 122, 113, 0.25);
    }

    .ghost {
      background: #fff;
      border: 1px solid var(--line);
      color: var(--ink);
    }

    .accent {
      background: var(--accent-2);
      color: #fff;
    }

    .section-note {
      font-size: 13px;
      color: var(--muted);
    }

    .tech-list {
      display: grid;
      gap: 12px;
    }

    .tech-item {
      display: grid;
      gap: 10px;
      padding: 12px;
      border-radius: 14px;
      border: 1px dashed #f0c94f;
      background: #fffdf8;
    }

    .preview {
      background: #14171c;
      color: #fff;
      border-radius: var(--radius);
      padding: 16px;
      font-family: "IBM Plex Sans", sans-serif;
      white-space: pre-wrap;
      min-height: 160px;
    }

    .footer-note {
      font-size: 12px;
      color: #6b6f76;
    }

    .reveal {
      opacity: 0;
      transform: translateY(16px);
      animation: fadeIn 0.7s ease forwards;
    }

    .reveal.delay-1 {
      animation-delay: 0.08s;
    }

    .reveal.delay-2 {
      animation-delay: 0.16s;
    }

    .reveal.delay-3 {
      animation-delay: 0.24s;
    }

    @keyframes fadeIn {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @media (max-width: 640px) {
      .panel {
        padding: 16px;
      }

      button {
        width: 100%;
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="container">
      <header class="reveal">
        <div class="pill">Telegram miniapp • GitHub Pages</div>
        <h1>Отчет смены за 1 минуту</h1>
        <div class="subtitle">
          Заполните форму, сгенерируйте текст и откройте ссылку Share — Telegram предложит
          отправить пост в общий чат.
        </div>
      </header>

      <form id="shift-form" class="panel reveal delay-1">
        <div class="panel-title"><span></span>Основные данные</div>
        <div class="grid two">
          <label>
            Дата
            <input type="date" name="date" required />
          </label>
          <label>
            Имя бригадира
            <input type="text" name="foreman" placeholder="Например: Хабиб" required />
          </label>
          <label>
            Смена
            <input type="text" name="shift" placeholder="Например: 1" />
          </label>
          <label>
            Хэштег / объект
            <input type="text" name="tag" placeholder="Например: Муссо" />
          </label>
        </div>

        <div class="grid three">
          <label>
            Смена: начало
            <input type="time" name="shiftStart" />
          </label>
          <label>
            Смена: конец
            <input type="time" name="shiftEnd" />
          </label>
          <label class="switch">
            <input type="checkbox" name="shiftLunch" checked />
            Смена с обедом
          </label>
        </div>

        <div class="panel-title"><span></span>Разнорабочие</div>
        <div class="grid three">
          <label>
            Свои
            <input type="number" min="0" name="workersOwn" value="0" />
          </label>
          <label>
            Наемники
            <input type="number" min="0" name="workersHire" value="0" />
          </label>
          <label>
            На базе
            <input type="number" min="0" name="workersBase" value="0" />
          </label>
        </div>

        <div class="grid three">
          <label>
            Разнорабочие: начало
            <input type="time" name="workersStart" />
          </label>
          <label>
            Разнорабочие: конец
            <input type="time" name="workersEnd" />
          </label>
          <label class="switch">
            <input type="checkbox" name="workersLunch" checked />
            С обедом
          </label>
        </div>

        <div class="panel-title"><span></span>Техника</div>
        <div class="section-note">Можно добавить несколько единиц техники.</div>
        <div id="tech-list" class="tech-list"></div>
        <div class="btn-row">
          <button class="ghost" type="button" id="add-tech">Добавить технику</button>
        </div>

        <div class="panel-title"><span></span>Работы и адреса</div>
        <div class="grid">
          <label>
            Виды работ (через запятую или с новой строки)
            <textarea name="workTypes" placeholder="Например: уборка, расчистка проезжей части"></textarea>
          </label>
          <label>
            Адреса выполненных работ (каждая строка — новый адрес)
            <textarea name="addresses" placeholder="Например: 13285035 Ленина, д.19 ✅"></textarea>
          </label>
        </div>

        <div class="panel-title"><span></span>Дополнительно</div>
        <div class="grid">
          <label>
            Комментарий
            <textarea name="note" placeholder="Что важно отметить"></textarea>
          </label>
        </div>
      </form>

      <section class="panel reveal delay-2">
        <div class="panel-title"><span></span>Предпросмотр</div>
        <div id="preview" class="preview">Заполните форму, чтобы увидеть текст отчета.</div>
        <div class="btn-row">
          <button class="primary" type="button" id="open-share">Открыть Share в Telegram</button>
          <button class="ghost" type="button" id="copy-text">Скопировать текст</button>
          <button class="accent" type="button" id="fill-sample">Заполнить примером</button>
        </div>
        <div class="footer-note">Share откроется в Telegram, а текст будет уже заполнен.</div>
      </section>
    </div>
  </div>

  <script>
    const form = document.getElementById("shift-form");
    const preview = document.getElementById("preview");
    const techList = document.getElementById("tech-list");
    const addTechButton = document.getElementById("add-tech");

    const BOT_USERNAME = "eav93tabelbot";
    const APP_SHORTNAME = "create";

    const createTechRow = (data = {}) => {
      const wrapper = document.createElement("div");
      wrapper.className = "tech-item";
      wrapper.innerHTML = `
        <div class="grid two">
          <label>
            Наименование техники
            <input type="text" name="techName" placeholder="Например: JCB" value="${data.name || ""}" />
          </label>
          <label>
            Имя водителя
            <input type="text" name="techDriver" placeholder="Например: Хабиб" value="${data.driver || ""}" />
          </label>
        </div>
        <div class="grid three">
          <label>
            Начало работы
            <input type="time" name="techStart" value="${data.start || ""}" />
          </label>
          <label>
            Конец работы
            <input type="time" name="techEnd" value="${data.end || ""}" />
          </label>
          <label class="switch">
            <input type="checkbox" name="techLunch" ${data.lunch ? "checked" : ""} />
            С обедом
          </label>
        </div>
        <button class="ghost" type="button" data-remove>Удалить</button>
      `;

      wrapper.querySelector("[data-remove]").addEventListener("click", () => {
        wrapper.remove();
        updatePreview();
      });

      wrapper.querySelectorAll("input").forEach((input) => {
        input.addEventListener("input", updatePreview);
        input.addEventListener("change", updatePreview);
      });

      return wrapper;
    };

    const formatLunch = (checked) => (checked ? "с обедом" : "без обеда");

    const formatRange = (start, end) => {
      if (!start && !end) return "";
      if (start && end) return `с ${start} до ${end}`;
      if (start) return `с ${start}`;
      return `до ${end}`;
    };

    const sanitizeLines = (text) =>
      text
        .split("\n")
        .map((line) => line.trim())
        .filter(Boolean);

    const formatDate = (value) => {
      const match = /^(\d{4})-(\d{2})-(\d{2})$/.exec(value);
      if (!match) return value;
      return `${match[3]}.${match[2]}.${match[1].slice(-2)}`;
    };

    const updatePreview = () => {
      const data = new FormData(form);
      const date = formatDate(data.get("date") || "");
      const foreman = data.get("foreman") || "";
      const shift = data.get("shift") || "";
      const tag = data.get("tag") || "";

      const shiftRange = formatRange(data.get("shiftStart"), data.get("shiftEnd"));
      const shiftLunch = formatLunch(data.get("shiftLunch"));
      const shiftHasTime = data.get("shiftStart") || data.get("shiftEnd");

      const workersOwn = Number(data.get("workersOwn") || 0);
      const workersHire = Number(data.get("workersHire") || 0);
      const workersBase = Number(data.get("workersBase") || 0);
      const workersRange = formatRange(data.get("workersStart"), data.get("workersEnd"));
      const workersLunch = formatLunch(data.get("workersLunch"));
      const workersHasTime = data.get("workersStart") || data.get("workersEnd");

      const workTypes = sanitizeLines(data.get("workTypes") || "");
      const addresses = sanitizeLines(data.get("addresses") || "");
      const note = (data.get("note") || "").trim();

      const techRows = Array.from(techList.querySelectorAll(".tech-item")).map((row) => {
        const name = row.querySelector("[name=techName]").value.trim();
        const driver = row.querySelector("[name=techDriver]").value.trim();
        const start = row.querySelector("[name=techStart]").value;
        const end = row.querySelector("[name=techEnd]").value;
        const lunch = row.querySelector("[name=techLunch]").checked;

        if (!name && !driver && !start && !end) return null;

        const time = formatRange(start, end);
        const lunchText = formatLunch(lunch);
        const driverText = driver ? ` (${driver})` : "";
        const timeText = time ? `${time}` : "";
        const lunchSuffix = timeText ? `, ${lunchText}` : lunchText;

        return `${name || "Техника"}${driverText}${timeText ? " " + timeText : ""}${lunchSuffix ? " " + lunchSuffix : ""}`.trim();
      });

      const techLines = techRows.filter(Boolean);

      const workerParts = [];
      if (workersOwn) workerParts.push(`${workersOwn} свои`);
      if (workersHire) workerParts.push(`${workersHire} наемники`);
      if (workersBase) workerParts.push(`${workersBase} свои на базе`);

      const lines = [];
      if (date) lines.push(date);
      if (tag) lines.push(`#${tag}${shift ? ` (смена ${shift})` : ""}`);
      if (foreman) lines.push(`Бригадир: ${foreman}`);

      if (workerParts.length) {
        lines.push("");
        lines.push(`Разнорабочие: ${workerParts.join(" + ")}`);
      }

      if (workersHasTime) {
        lines.push(`Время работы: ${workersRange || ""}${workersRange ? ", " : ""}${workersLunch}`.trim());
      }

      if (shiftHasTime) {
        lines.push(`Смена: ${shiftRange || ""}${shiftRange ? ", " : ""}${shiftLunch}`.trim());
      }

      if (techLines.length) {
        lines.push("");
        lines.push("Техника:");
        techLines.forEach((line) => lines.push(line));
      }

      if (workTypes.length) {
        lines.push("");
        lines.push(`Работы: ${workTypes.join(", ")}`);
      }

      if (addresses.length) {
        lines.push("");
        addresses.forEach((line) => lines.push(line));
      }

      if (note) {
        lines.push("");
        lines.push(note);
      }

      const text = lines.join("\n").trim();
      preview.textContent = text || "Заполните форму, чтобы увидеть текст отчета.";
    };

    const LZString = (() => {
      const f = String.fromCharCode;
      const keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

      const getBaseValue = (alphabet, character) => alphabet.indexOf(character);

      const compress = (uncompressed) => {
        if (uncompressed == null) return "";
        let i;
        let value;
        const context_dictionary = {};
        const context_dictionaryToCreate = {};
        let context_c = "";
        let context_wc = "";
        let context_w = "";
        let context_enlargeIn = 2;
        let context_dictSize = 3;
        let context_numBits = 2;
        const context_data = [];
        let context_data_val = 0;
        let context_data_position = 0;

        for (let ii = 0; ii < uncompressed.length; ii += 1) {
          context_c = uncompressed.charAt(ii);
          if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
            context_dictionary[context_c] = context_dictSize++;
            context_dictionaryToCreate[context_c] = true;
          }

          context_wc = context_w + context_c;
          if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
            context_w = context_wc;
          } else {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position === 5) {
                    context_data_position = 0;
                    context_data.push(f(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = (context_data_val << 1) | (value & 1);
                  if (context_data_position === 5) {
                    context_data_position = 0;
                    context_data.push(f(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = (context_data_val << 1) | value;
                  if (context_data_position === 5) {
                    context_data_position = 0;
                    context_data.push(f(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = (context_data_val << 1) | (value & 1);
                  if (context_data_position === 5) {
                    context_data_position = 0;
                    context_data.push(f(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn === 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position === 5) {
                  context_data_position = 0;
                  context_data.push(f(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn === 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            context_dictionary[context_wc] = context_dictSize++;
            context_w = String(context_c);
          }
        }

        if (context_w !== "") {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1;
                if (context_data_position === 5) {
                  context_data_position = 0;
                  context_data.push(f(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 8; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position === 5) {
                  context_data_position = 0;
                  context_data.push(f(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            } else {
              value = 1;
              for (i = 0; i < context_numBits; i++) {
                context_data_val = (context_data_val << 1) | value;
                if (context_data_position === 5) {
                  context_data_position = 0;
                  context_data.push(f(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 16; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position === 5) {
                  context_data_position = 0;
                  context_data.push(f(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn === 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (i = 0; i < context_numBits; i++) {
              context_data_val = (context_data_val << 1) | (value & 1);
              if (context_data_position === 5) {
                context_data_position = 0;
                context_data.push(f(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn === 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
        }

        value = 2;
        for (i = 0; i < context_numBits; i++) {
          context_data_val = (context_data_val << 1) | (value & 1);
          if (context_data_position === 5) {
            context_data_position = 0;
            context_data.push(f(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }

        while (true) {
          context_data_val = context_data_val << 1;
          if (context_data_position === 5) {
            context_data.push(f(context_data_val));
            break;
          } else {
            context_data_position++;
          }
        }
        return context_data.join("");
      };

      const decompress = (compressed) => {
        if (compressed == null) return "";
        if (compressed === "") return null;
        const dictionary = [];
        let next;
        let enlargeIn = 4;
        let dictSize = 4;
        let numBits = 3;
        let entry = "";
        const result = [];
        let i;
        let w;
        let bits;
        let resb;
        let maxpower;
        let power;
        const data = { val: compressed.charCodeAt(0), position: 32768, index: 1 };

        const getNextValue = () => data.val;

        for (i = 0; i < 3; i += 1) {
          dictionary[i] = i;
        }

        bits = 0;
        maxpower = Math.pow(2, 2);
        power = 1;
        while (power !== maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position === 0) {
            data.position = 32768;
            data.val = compressed.charCodeAt(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }

        switch (bits) {
          case 0:
            bits = 0;
            maxpower = Math.pow(2, 8);
            power = 1;
            while (power !== maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position === 0) {
                data.position = 32768;
                data.val = compressed.charCodeAt(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            next = f(bits);
            break;
          case 1:
            bits = 0;
            maxpower = Math.pow(2, 16);
            power = 1;
            while (power !== maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position === 0) {
                data.position = 32768;
                data.val = compressed.charCodeAt(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            next = f(bits);
            break;
          case 2:
            return "";
          default:
            return "";
        }

        dictionary[3] = next;
        w = next;
        result.push(next);

        while (true) {
          if (data.index > compressed.length) return "";

          bits = 0;
          maxpower = Math.pow(2, numBits);
          power = 1;
          while (power !== maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position === 0) {
              data.position = 32768;
              data.val = compressed.charCodeAt(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }

          switch (bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power !== maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position === 0) {
                  data.position = 32768;
                  data.val = compressed.charCodeAt(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }

              dictionary[dictSize++] = f(bits);
              bits = dictSize - 1;
              enlargeIn--;
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power !== maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position === 0) {
                  data.position = 32768;
                  data.val = compressed.charCodeAt(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              dictionary[dictSize++] = f(bits);
              bits = dictSize - 1;
              enlargeIn--;
              break;
            case 2:
              return result.join("");
            default:
              break;
          }

          if (enlargeIn === 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }

          if (dictionary[bits]) {
            entry = dictionary[bits];
          } else if (bits === dictSize) {
            entry = w + w.charAt(0);
          } else {
            return null;
          }
          result.push(entry);

          dictionary[dictSize++] = w + entry.charAt(0);
          enlargeIn--;
          w = entry;

          if (enlargeIn === 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
        }
      };

      const compressToBase64 = (input) => {
        if (input == null) return "";
        const res = compress(input);
        let i;
        let output = "";
        for (i = 0; i < res.length * 2; i += 3) {
          const chr1 = res.charCodeAt(i / 2);
          const chr2 = res.charCodeAt((i / 2) + 1);
          const chr3 = res.charCodeAt((i / 2) + 2);
          const enc1 = chr1 >> 2;
          const enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
          let enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
          let enc4 = chr3 & 63;

          if (isNaN(chr2)) {
            enc3 = enc4 = 64;
          } else if (isNaN(chr3)) {
            enc4 = 64;
          }

          output +=
            keyStrBase64.charAt(enc1) +
            keyStrBase64.charAt(enc2) +
            keyStrBase64.charAt(enc3) +
            keyStrBase64.charAt(enc4);
        }
        return output;
      };

      const decompressFromBase64 = (input) => {
        if (input == null) return "";
        if (input === "") return null;
        let i;
        let output = "";
        let chr1;
        let chr2;
        let chr3;
        let enc1;
        let enc2;
        let enc3;
        let enc4;
        let ol = 0;
        let output_;
        let output__ = [];

        input = input.replace(/[^A-Za-z0-9+/=]/g, "");
        for (i = 0; i < input.length; i += 4) {
          enc1 = getBaseValue(keyStrBase64, input.charAt(i));
          enc2 = getBaseValue(keyStrBase64, input.charAt(i + 1));
          enc3 = getBaseValue(keyStrBase64, input.charAt(i + 2));
          enc4 = getBaseValue(keyStrBase64, input.charAt(i + 3));

          chr1 = (enc1 << 2) | (enc2 >> 4);
          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
          chr3 = ((enc3 & 3) << 6) | enc4;

          if (enc3 !== 64) {
            output__[ol++] = f(chr1);
            output__[ol++] = f(chr2);
          } else {
            output__[ol++] = f(chr1);
          }

          if (enc4 !== 64) {
            output__[ol++] = f(chr3);
          }
        }

        output = output__.join("");
        output_ = decompress(output);
        return output_;
      };

      return {
        compressToBase64,
        decompressFromBase64,
      };
    })();

    const base64UrlEncode = (value) =>
      btoa(unescape(encodeURIComponent(value)))
        .replace(/\+/g, "-")
        .replace(/\//g, "_")
        .replace(/=+$/, "");

    const base64UrlDecode = (value) => {
      const padded = value.replace(/-/g, "+").replace(/_/g, "/");
      const padLength = padded.length % 4 ? 4 - (padded.length % 4) : 0;
      const base64 = padded + "=".repeat(padLength);
      return decodeURIComponent(escape(atob(base64)));
    };

    const lzCompressToUrl = (value) =>
      LZString.compressToBase64(value)
        .replace(/\+/g, "-")
        .replace(/\//g, "_")
        .replace(/=+$/, "");

    const lzDecompressFromUrl = (value) => {
      const padded = value.replace(/-/g, "+").replace(/_/g, "/");
      const padLength = padded.length % 4 ? 4 - (padded.length % 4) : 0;
      const base64 = padded + "=".repeat(padLength);
      return LZString.decompressFromBase64(base64);
    };

    const collectFormData = () => {
      const tech = Array.from(techList.querySelectorAll(".tech-item"))
        .map((row) => {
          const name = row.querySelector("[name=techName]").value.trim();
          const driver = row.querySelector("[name=techDriver]").value.trim();
          const start = row.querySelector("[name=techStart]").value || "";
          const end = row.querySelector("[name=techEnd]").value || "";
          const lunch = row.querySelector("[name=techLunch]").checked;

          if (!name && !driver && !start && !end) return null;

          return { name, driver, start, end, lunch };
        })
        .filter(Boolean);

      return {
        date: form.elements.date.value || "",
        foreman: form.elements.foreman.value.trim(),
        shift: form.elements.shift.value.trim(),
        tag: form.elements.tag.value.trim(),
        shiftStart: form.elements.shiftStart.value || "",
        shiftEnd: form.elements.shiftEnd.value || "",
        shiftLunch: form.elements.shiftLunch.checked,
        workersOwn: Number(form.elements.workersOwn.value || 0),
        workersHire: Number(form.elements.workersHire.value || 0),
        workersBase: Number(form.elements.workersBase.value || 0),
        workersStart: form.elements.workersStart.value || "",
        workersEnd: form.elements.workersEnd.value || "",
        workersLunch: form.elements.workersLunch.checked,
        workTypes: form.elements.workTypes.value.trim(),
        addresses: form.elements.addresses.value.trim(),
        note: form.elements.note.value.trim(),
        tech,
      };
    };

    const packFormData = (payload) => [
      payload.date || "",
      payload.foreman || "",
      payload.shift || "",
      payload.tag || "",
      payload.shiftStart || "",
      payload.shiftEnd || "",
      payload.shiftLunch ? 1 : 0,
      payload.workersOwn || 0,
      payload.workersHire || 0,
      payload.workersBase || 0,
      payload.workersStart || "",
      payload.workersEnd || "",
      payload.workersLunch ? 1 : 0,
      payload.workTypes || "",
      payload.addresses || "",
      payload.note || "",
      Array.isArray(payload.tech)
        ? payload.tech.map((item) => [
            item.name || "",
            item.driver || "",
            item.start || "",
            item.end || "",
            item.lunch ? 1 : 0,
          ])
        : [],
    ];

    const unpackFormData = (packed) => {
      if (!Array.isArray(packed)) return null;
      const techPacked = Array.isArray(packed[16]) ? packed[16] : [];
      const tech = techPacked.map((item) => ({
        name: item[0] || "",
        driver: item[1] || "",
        start: item[2] || "",
        end: item[3] || "",
        lunch: Boolean(item[4]),
      }));

      return {
        date: packed[0] || "",
        foreman: packed[1] || "",
        shift: packed[2] || "",
        tag: packed[3] || "",
        shiftStart: packed[4] || "",
        shiftEnd: packed[5] || "",
        shiftLunch: Boolean(packed[6]),
        workersOwn: Number(packed[7] || 0),
        workersHire: Number(packed[8] || 0),
        workersBase: Number(packed[9] || 0),
        workersStart: packed[10] || "",
        workersEnd: packed[11] || "",
        workersLunch: Boolean(packed[12]),
        workTypes: packed[13] || "",
        addresses: packed[14] || "",
        note: packed[15] || "",
        tech,
      };
    };

    const applyFormData = (payload) => {
      if (!payload || typeof payload !== "object") return;

      if (payload.date) form.elements.date.value = payload.date;
      if (payload.foreman) form.elements.foreman.value = payload.foreman;
      if (payload.shift) form.elements.shift.value = payload.shift;
      if (payload.tag) form.elements.tag.value = payload.tag;

      if (payload.shiftStart) form.elements.shiftStart.value = payload.shiftStart;
      if (payload.shiftEnd) form.elements.shiftEnd.value = payload.shiftEnd;
      if (typeof payload.shiftLunch === "boolean") {
        form.elements.shiftLunch.checked = payload.shiftLunch;
      }

      if (payload.workersOwn !== undefined) form.elements.workersOwn.value = payload.workersOwn;
      if (payload.workersHire !== undefined) form.elements.workersHire.value = payload.workersHire;
      if (payload.workersBase !== undefined) form.elements.workersBase.value = payload.workersBase;
      if (payload.workersStart) form.elements.workersStart.value = payload.workersStart;
      if (payload.workersEnd) form.elements.workersEnd.value = payload.workersEnd;
      if (typeof payload.workersLunch === "boolean") {
        form.elements.workersLunch.checked = payload.workersLunch;
      }

      if (payload.workTypes) form.elements.workTypes.value = payload.workTypes;
      if (payload.addresses) form.elements.addresses.value = payload.addresses;
      if (payload.note) form.elements.note.value = payload.note;

      techList.innerHTML = "";
      if (Array.isArray(payload.tech) && payload.tech.length) {
        payload.tech.forEach((item) => techList.appendChild(createTechRow(item)));
      }

      if (!techList.childElementCount) {
        techList.appendChild(createTechRow({ lunch: true }));
      }
    };

    const loadFromTelegram = () => {
      if (!window.Telegram || !window.Telegram.WebApp) return false;
      const unsafe = window.Telegram.WebApp.initDataUnsafe;
      if (!unsafe || !unsafe.start_param) return false;
      try {
        const raw = unsafe.start_param;
        const decodedParam = /%[0-9A-Fa-f]{2}/.test(raw) ? decodeURIComponent(raw) : raw;
        const unpacked = decodePayload(decodedParam);
        if (!unpacked) return false;
        applyFormData(unpacked);
        return true;
      } catch (err) {
        return false;
      }
    };

    const loadFromUrl = () => {
      const params = new URLSearchParams(window.location.search);
      const encoded = params.get("data");
      if (!encoded) return false;
      try {
        const unpacked = decodePayload(encoded);
        if (!unpacked) return false;
        applyFormData(unpacked);
        return true;
      } catch (err) {
        return false;
      }
    };

    const decodePayload = (encoded) => {
      const json = lzDecompressFromUrl(encoded);
      if (json) {
        try {
          const parsed = JSON.parse(json);
          return Array.isArray(parsed) ? unpackFormData(parsed) : parsed;
        } catch (err) {
          return null;
        }
      }

      try {
        const fallbackJson = base64UrlDecode(encoded);
        const parsed = JSON.parse(fallbackJson);
        return Array.isArray(parsed) ? unpackFormData(parsed) : parsed;
      } catch (err) {
        return null;
      }
    };

    const getMiniAppDeepLink = (payload) =>
      `https://t.me/${BOT_USERNAME}/${APP_SHORTNAME}?startapp=${payload}`;

    const getShareUrl = (text) => {
      const payload = collectFormData();
      const packed = packFormData(payload);
      const data = lzCompressToUrl(JSON.stringify(packed));
      const deepLink = getMiniAppDeepLink(data);
      return `https://t.me/share/url?url=${encodeURIComponent(deepLink)}&text=${encodeURIComponent(text)}`;
    };

    const openShare = () => {
      const text = preview.textContent.trim();
      if (!text || text === "Заполните форму, чтобы увидеть текст отчета.") {
        alert("Сначала заполните форму.");
        return;
      }
      window.location.href = getShareUrl(text);
    };

    const copyText = async () => {
      const text = preview.textContent.trim();
      if (!text || text === "Заполните форму, чтобы увидеть текст отчета.") {
        alert("Сначала заполните форму.");
        return;
      }
      try {
        await navigator.clipboard.writeText(text);
        alert("Текст скопирован.");
      } catch (err) {
        alert("Не удалось скопировать текст.");
      }
    };

    const fillSample = () => {
      form.elements.date.value = "2026-01-16";
      form.elements.foreman.value = "Хабиб";
      form.elements.shift.value = "1";
      form.elements.tag.value = "Муссо";
      form.elements.shiftStart.value = "09:00";
      form.elements.shiftEnd.value = "17:00";
      form.elements.shiftLunch.checked = true;

      form.elements.workersOwn.value = 3;
      form.elements.workersHire.value = 5;
      form.elements.workersBase.value = 2;
      form.elements.workersStart.value = "09:00";
      form.elements.workersEnd.value = "17:00";
      form.elements.workersLunch.checked = true;

      techList.innerHTML = "";
      techList.appendChild(
        createTechRow({
          name: "JCB",
          driver: "Хабиб",
          start: "09:00",
          end: "17:00",
          lunch: true,
        })
      );

      form.elements.workTypes.value = "доброделы уборка, расчистка проезжей части";
      form.elements.addresses.value = `24. 13285035 Ленина, д.19,17, ✅\n25. 13285206 Ленина, д.19,17 ✅\n26. 13236354 Ленина, д.19,17 ✅\n27. 13275700 Ленина, д.19,17 ✅\n13235630 Ленина 19, ✅\n13235681 Ленина 19, ✅\n13280306 Ленина 23, ❌\n29. 13284592 Ленина, д.23, Юбилейная, д.8 ❌\n30. 13284131 Ленина, д.19,17, ❌\n\n40. 13276451 Крупской, д.12,12А,16 ❌\n41. 13268351 Крупской, д.12,12А,16 ❌\n42. 13268351 Крупской, д.12,12А,16 ❌\n13295190 Крупской, ❌\n13242008 Крупской, ❌\n13231065 Крупской, ❌\n13235704 Крупской, ❌\n13283989 Крупской, ❌\n13295190 Крупской, ❌\n13242008 Крупской, ❌\n13295190 Юбилейная 4, ❌`;
      form.elements.note.value = "";

      updatePreview();
    };

    addTechButton.addEventListener("click", () => {
      techList.appendChild(createTechRow({ lunch: true }));
      updatePreview();
    });

    form.addEventListener("input", updatePreview);
    form.addEventListener("change", updatePreview);

    document.getElementById("open-share").addEventListener("click", openShare);
    document.getElementById("copy-text").addEventListener("click", copyText);
    document.getElementById("fill-sample").addEventListener("click", fillSample);

    const loadedFromTelegram = loadFromTelegram();
    if (!loadedFromTelegram) {
      loadFromUrl();
    }

    const now = new Date();
    if (form.elements.date && !form.elements.date.value) {
      form.elements.date.value = now.toISOString().slice(0, 10);
    }

    if (!techList.childElementCount) {
      techList.appendChild(createTechRow({ lunch: true }));
    }
    updatePreview();
  </script>
</body>
</html>
